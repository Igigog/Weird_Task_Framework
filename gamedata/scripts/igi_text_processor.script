local trace_assert  = igi_helper.trace_assert

local fCache = {}
local function eval(v)
	local f = fCache[v]
	if f == nil then
		f = loadstring("return " .. v)
		fCache[v] = f
	end
	assert(f, "Function cannot be compiled: " .. (v or nil))
	return f()
end

LinkContext  = {
	_NO_THIS = {},

	new = function(self, CACHE)
		local link_context = {
			CACHE = CACHE,
			this = self._NO_THIS,
			__transient = {}
		}
		for _, entity in pairs(CACHE.entities) do
			link_context.__transient[entity] = {}
			if entity.link_id then
				trace_assert(link_context[entity.link_id] == nil, "Entity already in context", link_context, entity)
				link_context[entity.link_id] = entity
			end
		end
		return setmetatable(link_context, { __index = self })
	end,

	set_this = function (self, entity)
		self.this = entity or LinkContext._NO_THIS
		return self
    end,

    set_transient = function(self, tbl, key, val)
		local transient_fields = self.__transient[tbl]
		if not transient_fields then return end
		transient_fields[key] = tbl[key]
		tbl[key] = val
	end,

	get = function (self, link)
        local tbl = self[link.link_id]
        igi_helper.trace_assert(tbl, "Linker can't find tbl for link:", self)
		return tbl[link.field]
	end,

	get_table = function (self, link)
		local tbl = self[link.link_id]
        igi_helper.trace_assert(tbl, "Linker can't find tbl for link:", self)
		return tbl
	end,

	reset_transient = function (self)
		for tbl, tr_tbl in pairs(self.__transient) do
			for k, v in pairs(tr_tbl) do
				tbl[k] = v
			end
		end
	end
}

Link = {
	new = function (link_id, field)
		local t = {
			link_id = link_id,
			field = field,
		}

		return setmetatable(t, {__index = Link})
    end,

	from_str = function (self, str)
		local link_id, field = str:match("%|([^%.]+)%.(.+)%|")
		trace_assert(link_id and field, "Link can't be resolved: " .. str)
		return Link.new(link_id, field)
	end,

	remap_this = function (self, mapping)
        if mapping and self.link_id == "this" then
            self.link_id = mapping
        end
		return self
	end
}

Macro       = {
	link_context = {},

    new = function(self, str)
        local level, is_auto, macro = string.match(str, "([^%$%@]*)(%@?)%$(.*)")
        if not macro then return end

        local t = {
            level = level,
            is_auto = is_auto ~= '',
            macro = macro,
			orig = str
        }

        return setmetatable(t, { __index = self })
    end,

	_without_links = function (self)
        return string.gsub(self.macro, "%b||", function(dep)
			local link = Link:from_str(dep)
			return "igi_text_processor.Macro.link_context." .. link.link_id .. '.' .. link.field
		end)
	end,

    resolve = function(self, link_context, log)
		if log then igi_helper.trace_dbg("Resolving macro", self.orig) end

		Macro.link_context = link_context
		local out = eval(self:_without_links())

		trace_assert(out ~= nil, "Macro returned nil", self.orig)
		trace_assert(type(out) ~= "userdata", "Macro returned userdata", self.orig)

		return out
    end,

	assert_level = function (self, level)
		igi_helper.trace_assert(self.level == level, "Macro is of wrong level", level, self.orig)
		return self
	end,

	link_iterator = function (self)
        return string.gmatch(self.macro, "%b||")
	end
}

-- Careful if you want to cache it: generate step invalidates link context
function get_link_context(CACHE, entity)
	return LinkContext:new(CACHE):with_this(entity)
end

function has_macro(str)
    return Macro:new(str) ~= nil
end

local function resolve_macros(tbl, level, link_context)
    for k, v in pairs(tbl) do
        if type(v) == 'table' then
            resolve_macros(v, level, link_context)
        elseif type(v) == 'string' then
            local out = resolve_linked_macro(v, level, link_context)
            if out ~= v then
                trace_assert(out ~= nil, "Macro returned nil", v)
                trace_assert(type(out) ~= "userdata", "Macro returned userdata", v)
                tbl[k] = out
            end
        end
    end
end

function collect_links(macro, link_context, buf, visited, this_mapping)
    for dep in macro:link_iterator() do
        local link = Link:from_str(dep):remap_this(this_mapping)

        local repr = link.link_id .. '.' .. link.field
        igi_helper.trace_assert(not visited[repr], "Circular dependency found! ", dep, macro)
		visited[repr] = true

		buf[#buf + 1] = link
        local val = link_context:get(link)

        local macro = Macro:new(val)
        if macro then
            collect_links(macro, link_context, buf, visited, link.link_id)
        end
    end
    return buf
end

function resolve_all_links(links, level, link_context, log)
	for i = #links, 1, -1 do
        local link = links[i]
        local tbl = link_context:get_table(link)
        local before = tbl[link.field]
        igi_helper.trace_assert(before ~= nil, "Link is nil", link)

        local macro = Macro:new(before)
        if not macro then
            return before
        end

		macro:assert_level(level)
        tbl[link.field] = macro:resolve(link_context:set_this(tbl), log)
	end
end

function resolve_linked_macro(val, level, link_context, log)
    local macro = Macro:new(val)
	if (not macro) or macro.level ~= level then
		return val
	end
    local links = collect_links(macro, link_context, {}, {})
    resolve_all_links(links, level, link_context, log)
	return macro:resolve(link_context)
end

function resolve_and_link_cache(CACHE, level)
    local link_context = igi_text_processor.get_link_context(CACHE)

    for _, entity in pairs(CACHE.entities) do
        resolve_macros(entity, link_context:set_this(entity), level)
    end

	resolve_macros(CACHE, link_context, level)
	link_context:reset_transient()
end

function eval_logic_macro(str, link_context, log)
	local resolved = resolve_linked_macro(str, "@", link_context, log)
	trace_assert(resolved ~= str, "Not a @$ macro or not resolved", str)
	return resolved
end
