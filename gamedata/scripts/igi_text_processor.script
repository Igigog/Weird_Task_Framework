local trace_assert  = igi_helper.trace_assert

LinkContext  = {
	_link_prefix = "__igi__link_",
	_NO_THIS = {},

	new = function(self, CACHE)
		local link_context = {
			CACHE = CACHE,
			this = self._NO_THIS
		}
		for _, entity in pairs(CACHE.entities) do
			if entity.link_id then
				trace_assert(link_context[entity.link_id] == nil, "Entity already in context", link_context, entity)
				link_context[entity.link_id] = entity
			end
		end
		return setmetatable(link_context, { __index = self })
	end,

	set_this = function(self, entity)
		self.this = entity or self._NO_THIS
	end,

	to_env = function (self)
		local env = {}
		for k, v in pairs(self) do
			env[LinkContext._link_prefix .. k] = v
		end
		return env
	end,

	with_this = function (self, entity)
		return setmetatable({this = entity}, {__index = self})
    end,

	get = function (self, link)
        local tbl = self[link.link_id]
        igi_helper.trace_assert(tbl, "Linker can't find tbl for link:", self)
		return tbl[link.field], link.link_id
	end,

	get_table = function (self, link)
		local tbl = self[link.link_id]
        igi_helper.trace_assert(tbl, "Linker can't find tbl for link:", self)
		return tbl
	end
}

Link = {
	new = function (link_id, field)
		local t = {
			link_id = link_id,
			field = field,
		}

		return setmetatable(t, {__index = Link})
	end,

	as_variable = function (self)
		return LinkContext._link_prefix .. self.link_id .. "." .. self.field
    end,
	
	remap_this = function (self, mapping)
        if mapping and self.link_id == "this" then
            self.link_id = mapping
        end
		return self
	end
}

local fCache = {}
local function eval(v, env)
	local f = fCache[v]
	if f == nil then
		f = loadstring("return " .. v)
		fCache[v] = f
	end
	assert(f, "Function cannot be compiled: " .. (v or nil))

	setfenv(f, setmetatable(env or {}, {__index = _G}))
	return f()
end

-- Careful if you want to cache it: generate step invalidates link context
function get_link_context(CACHE, entity)
	local link_context = LinkContext:new(CACHE)
	link_context:set_this(entity)
	return link_context
end

function escape_pattern(text)
    return text:gsub("([^%w])", "%%%1")
end

local function str_to_link(str)
	local link_id, field = str:match("%|([^%.]+)%.(.+)%|")
	trace_assert(link_id and field, "Link can't be resolved: " .. str)
	return Link.new(link_id, field)
end

local function link_iterator(str)
	return str:gmatch("%b||")
end

local function str_to_macro(str)
	return string.match(str, "([^%$]*)%$(.*)")
end

function has_macro(str)
	return str_to_macro(str) ~= nil
end

local function resolve_macro(macro, link_context)
	return eval(macro, link_context:to_env())
end

local function resolve_links_in_str(str)
	return string.gsub(str, "%b||", function (dep)
		return str_to_link(dep):as_variable()
	end)
end

local function resolve_macros(tbl, level, link_context)
    for k, v in pairs(tbl) do
        if type(v) == 'table' then
            resolve_macros(v, level, link_context)
        elseif type(v) == 'string' then
            local out = resolve_linked_macro(v, level, link_context)
            if out ~= v then
                trace_assert(out ~= nil, "Macro returned nil", v)
                tbl[k] = out
            end
        end
    end
end

function collect_links(macro, link_context, buf, this_mapping)
    for dep in link_iterator(macro) do
        local link = str_to_link(dep):remap_this(this_mapping)
        buf[#buf + 1] = link
        local val, link_id = link_context:get(link)

        local macro = str_to_macro(val)
        if macro then
            collect_links(macro, link_context, buf, link_id)
        end
    end
    return buf
end

function resolve_all_links(links, level, link_context)
	for i = #links, 1, -1 do
        local link = links[i]
        local tbl = link_context:get_table(link)
        local before = tbl[link.field]
        igi_helper.trace_assert(before ~= nil, "Link is nil", link)
		
        local macro, macro_level = str_to_macro(before)
        if not macro then
            return before
        end
		
        igi_helper.trace_assert(macro_level == level, "Macro is of wrong level", level, before)
		if log then igi_helper.trace_dbg("Resolving macro " .. macro) end
        local without_links = resolve_links_in_str(macro)
		tbl[link.field] = resolve_macro(without_links, link_context:with_this(tbl))
	end
end

function resolve_linked_macro(val, level, link_context)
    local macro, macro_level = str_to_macro(val)
	if not macro or macro_level ~= level then
		return val
	end
    local links = collect_links(macro, link_context, {})
    resolve_all_links(links, level, link_context)
	return resolve_macro(macro, link_context)
end

local function resolve_macros_and_link_variables(CACHE, link_context, level)
	for _, entity in pairs(CACHE.entities) do
		link_context:set_this(entity)
		resolve_macros(entity, link_context, level)
	end
end

function resolve_and_link_cache(CACHE, level)
	local link_context = igi_text_processor.get_link_context(CACHE)
	resolve_macros_and_link_variables(CACHE, link_context, level)
	resolve_macros(CACHE, link_context, level)
end

function eval_logic_macro(str, link_context, log)
	local resolved = resolve_linked_macro(str, "@", link_context)
	trace_assert(resolved ~= str, "Not a @$ macro or not resolved", str)
	return resolved
end
