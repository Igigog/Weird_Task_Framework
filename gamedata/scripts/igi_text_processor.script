local trace_dbg = igi_helper.trace_dbg
local trace_assert  = igi_helper.trace_assert
local convert_type = igi_utils.convert_type

LinkContext  = {
	_link_prefix = "__igi__link_",

	new = function(self, CACHE)
		local link_context = {
			CACHE = CACHE,
			this = {}
		}
		for _, entity in pairs(CACHE.entities) do
			if entity.link_id then
				trace_assert(link_context[entity.link_id] == nil, "Entity already in context", link_context, entity)
				link_context[entity.link_id] = entity
			end
		end
		return setmetatable(link_context, { __index = self })
	end,

	set_this = function(self, entity)
		self.this = entity
	end,

	get = function(self, key)
		return self[key]
	end,

	to_env = function (self)
		local env = {}
		for k, v in pairs(self) do
			env[LinkContext._link_prefix .. k] = v
		end
		return env
	end
}

Link = {
	new = function (link_id, field)
		local t = {
			link_id = link_id,
			field = field,
		}

		return setmetatable(t, {__index = Link})
	end,

	is_pointed_to = function (self, entity)
		return self.link_id == entity.link_id
	end,

	points_to_self = function (self)
		return self.link_id == "this"
	end,

    resolve = function(self, link_context)
		trace_dbg("Link resolve", self, link_context)
		local entity = link_context:get(self.link_id)
		trace_assert(entity, "Linker can't find entity for link:", self)
		local out = self:resolve_field(entity)
		return out and tostring(out) or nil
	end,

	resolve_field = function(self, entity)
		return entity[self.field]
    end,

	as_variable = function (self)
		return LinkContext._link_prefix .. self.link_id .. "." .. self.field
	end
}

local function str_to_link(str)
	local link = try_str_to_link(str)
	return trace_assert(link, "Link can't be resolved: " .. str)
end

local function link_iterator(str)
	return str:gmatch("%b[]")
end

local function has_link(str)
	return link_iterator(str)()
end

local function str_to_macro(str)
	return string.match(str, "%$(.*)")
end

local function resolve_macro(macro, link_context)
	return igi_helper.eval(macro, link_context:to_env())
end

local function resolve_links_in_str(str, link_context)
	local has_changes = false
	for dep in link_iterator(str) do
		local link = str_to_link(dep)
		local resolved = link:resolve(link_context)
		if resolved and not str_to_macro(resolved) then
			str = str:gsub(igi_utils.escape_pattern(dep), link:as_variable())
			has_changes = true
		end
	end
	return str, has_changes
end

local function resolve_free_dependencies(link_context, tbl)
	-- trace_dbg("resolve before ", tbl)
	local has_changes = false
	for k, v in pairs(tbl) do
		if type(v) == "table" then
			if resolve_free_dependencies(link_context, v) then
				has_changes = true
			end
		elseif type(v) == "string" then
			local str, changes = resolve_links_in_str(v, link_context)
			if changes then
				tbl[k] = str
				has_changes = true
			end
		end
	end
	-- trace_dbg("resolve after ", tbl, has_changes)
	return has_changes
end

local function resolve_in_str(str, resolve_bangs, link_context)
	local macro = str_to_macro(str)
	if macro ~= nil then
		if not has_link(str) and (resolve_bangs or string.sub(str, 1, 1) ~= "!") then
			trace_dbg("resolve macro", str, macro)
			local resolved = resolve_macro(macro, link_context)
			local resolved_str = type(resolved) == "table" and table.concat(resolved, ',') or resolved
			trace_dbg("resolved", str, resolved_str)
			return resolved_str
		end
	end

	return str
end

local function inner_resolve_and_link_table(tbl, link_context, resolve_bangs)
	local made_changes = false

	local has_changed = true
	while has_changed do
		has_changed = resolve_free_dependencies(link_context, tbl)
		has_changed = resolve_macros(tbl, resolve_bangs, link_context) or has_changed
		if has_changed then
			made_changes = true
		end
	end
	return made_changes
end

function resolve_macros_and_link_variables(CACHE, resolve_bangs)
	local link_context = LinkContext:new(CACHE)
	local has_changed = true
	while has_changed do
		has_changed = false
		for _, entity in pairs(CACHE.entities) do
			trace_dbg("Before resolve_and_link_entity", entity)
			link_context:set_this(entity)
			has_changed = inner_resolve_and_link_table(entity, link_context, resolve_bangs) or has_changed
			trace_dbg("After resolve_and_link_entity", entity)
		end
	end
end

function resolve_and_link_cache(CACHE, resolve_bangs)
	trace_dbg("Before resolve_and_link_cache", CACHE)
	resolve_macros_and_link_variables(CACHE, resolve_bangs)
	inner_resolve_and_link_table(CACHE, LinkContext:new(CACHE), resolve_bangs)
	trace_dbg("After resolve_and_link_cache", CACHE)
end

function try_str_to_link(str)
	local link_id, field = str:match("%[([^%.]+)%.(.+)%]")

	if not (link_id and field) then
		return nil
	end

	return Link.new(link_id, field)
end

function link_entity(str, entity)
	for dep in link_iterator(str) do
		local link = str_to_link(dep)
		if link:is_pointed_to(entity) then
			local val = link:resolve_field(entity)
			if val ~= nil then
				str = str:gsub(igi_utils.escape_pattern(dep), val)
			end
		end
	end
	return convert_type(str)
end

function has_no_outer_links(tbl, entity)
	for k,v in pairs(tbl) do
		if type(v) == 'string' then
			for str in link_iterator(v) do
				if not str_to_link(str):points_to_self() then
					return false
				end
			end
		elseif type(v) == 'table' and not has_no_outer_links(v, entity) then
			return false
		end
	end
	return true
end

function resolve_macros(tbl, resolve_bangs, link_context)
	local has_changed = false
	for k,v in pairs(tbl) do
		if type(v) == 'table' then
			has_changed = resolve_macros(v, resolve_bangs, link_context) or has_changed
		elseif type(v) == 'string' then
			local out = resolve_in_str(v, resolve_bangs, link_context)
			if out ~= v then
				tbl[k] = out ~= nil and out or "nil"
				has_changed = true
			end

		end
	end
	return has_changed
end
