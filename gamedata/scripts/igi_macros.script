local trace_dbg = igi_helper.trace_dbg
local Set = igi_utils.Set

local blacklist = {
	monolith = true,
	renegade = true,
	greh = true,
	isg = true,
}
local factions = {}
local function get_viable_factions()
	if not next(factions) then
		for _, faction in pairs(game_relations.factions_table) do
			if not blacklist[faction] then
				factions[faction] = true
			end
		end
	end
	return factions
end

local function get_faction(keyword, tg_faction)
	if keyword == "actor" then
		return db.actor:character_community()
	elseif keyword == 'taskgiver' then
		return tg_faction
	elseif get_viable_factions()[keyword] then
		return keyword
	end
	return nil
end

local evaluate, tokenize
function Faction(tg_id, args_str)
	local tokens = tokenize(args_str, igi_helper.get_community_by_id(tg_id))
	return evaluate(tokens, 1, #tokens)
end

----------------BOOLEAN----------------------------------

local function convert_to_faction_set(faction, tg_faction)
	local real_faction = get_faction(faction, tg_faction)
	return real_faction and {[real_faction] = true}
end

local function get_of_factions(key, faction)
	local is_in = key == "enemy" and game_relations.is_factions_enemies or game_relations.is_factions_friends
	local tbl = {}
	for k_faction in pairs(get_viable_factions()) do
		if is_in(faction, k_faction) then
			tbl[k_faction] = true
		end
	end
	return tbl
end

local function and_func(left, right)
    return Set.intersection(left, right)
end

local function or_func(left, right)
    return Set.union(left, right)
end

local function not_func(left, right)
	return Set.difference(get_viable_factions(), right)
end

local function of_func(left, right)
	local newset = {}
	for faction in pairs(right) do
		for of_faction in pairs(get_of_factions(left, faction)) do
			newset[of_faction] = true
		end
	end
    return newset
end

function tokenize(str, tg_faction)
    local tbl = {}
    str = str:gsub("%(", "%( "):gsub('%)', ' %)')
    for substr in str:gmatch("[^%s]+") do
        tbl[#tbl+1] = convert_to_faction_set(substr, tg_faction) or substr
    end
    return tbl
end

local function evaluate_no_par(tokens, tstart, tend)
    if tstart > tend then return nil end
    if tstart == tend then return tokens[tstart] end
    local last_and, last_or, last_not, last_of
    for i=tend,tstart,-1 do
        local token = tokens[i]
        if token == "and" then
            last_and = i
        elseif token == "or" then
            last_or = i
        elseif token == "not" then
            last_not = i
        elseif token == "of" then
            last_of = i
        end
    end
    if last_and then
		return and_func(evaluate_no_par(tokens, tstart, last_and-1), evaluate_no_par(tokens, last_and+1, tend))
    elseif last_or then
		return or_func(evaluate_no_par(tokens, tstart, last_or-1), evaluate_no_par(tokens, last_or+1, tend))
    elseif last_not then
		return not_func(evaluate_no_par(tokens, tstart, last_not-1),evaluate_no_par(tokens, last_not+1, tend))
    elseif last_of then
		return of_func(evaluate_no_par(tokens, tstart, last_of-1),evaluate_no_par(tokens, last_of+1, tend))
    end
end

function evaluate(tokens, tstart, tend)
    if tstart > tend then return nil end
    if tstart == tend then return tokens[tstart] end

    local new_tokens = {}
    local par_count = 0
    local par_start
    for i=tstart,tend do
        local token = tokens[i]
        if token == '(' then
            if par_count == 0 then
                par_start = i
            end
            par_count = par_count + 1

        elseif token == ')' then
            par_count = par_count - 1
            if par_count == 0 then
                new_tokens[#new_tokens + 1] = evaluate(tokens, par_start+1, i-1)
            end
        elseif par_count == 0 then
            new_tokens[#new_tokens + 1] = token
        end
    end
    return evaluate_no_par(new_tokens, 1, #new_tokens)
end
