-- There are purely utility functions, not bound with tasks or STALKER

local trace_assert = igi_helper.trace_assert

Set = {
	__cls = 'Set',

	new = function()
		return setmetatable({}, {__index = Set})
	end,

	union = function(self, set2)
		local new_set = dup_table(self)
		for k in pairs(set2) do
			new_set[k] = true
		end
		return new_set
	end,

	intersection = function(self, set2)
		local new_set = {}
		for k in pairs(set2) do
			new_set[k] = self[k]
		end
		return new_set
	end,

	difference = function(self, set2)
		local new_set = dup_table(self)
		for k in pairs(set2) do
			new_set[k] = nil
		end
		return new_set
	end,

	from_list = function(list)
		local new_set = {}
		for _, v in pairs(list) do
			new_set[v] = true
		end
		return new_set
	end,

	to_list = function(self)
		local tbl = {}
		for k in pairs(self) do
			tbl[#tbl + 1] = k
		end
		tbl.__cls = nil
		return tbl
	end,

	insert = function (self, k)
		self[k] = true
	end,

	is_subset = function (set1, set2)
		for k in pairs(set1) do
			if not set2[k] then
				return false
			end
		end
		return true
	end,
}

function random_table_element(tbl)
	-- It's preffered to use lists with igi_random.rand rather
	-- than this function bcs this function is slow
	local keyset = {}
	for k in pairs(tbl) do
		table.insert(keyset, k)
	end
	-- now you can reliably return a random key
	local random_key = keyset[igi_random.rand(#keyset)]
	local random_elem = tbl[random_key]
	return random_elem, random_key
end

function choose(...)
	local list = { ... }
	return list[igi_random.rand(#list)]
end

function get_random_items(orig_list, amount)
	if not orig_list or #orig_list < amount then
		return nil, "Not enough items"
	end

	local set = {}
	local list = {}
	for i=1, amount do
		local item
		repeat
			item = orig_list[igi_random.rand(#orig_list)]
		until not set[item]
		list[#list + 1] = item
		set[item] = true
	end
	return list
end

function extend_list(orig, val)
	-- add value to a list or add every value if val is a list
	if type(val) == 'table' then
		for _, v in pairs(val) do orig[#orig + 1] = v end
	else orig[#orig + 1] = val end
	return orig
end

function memoize_one_variable(f, id)
    local cache = MemoizeCache.new(id)
    return function (arg)
		local key = arg ~= nil and arg or "!nil!"
        if cache[key] then
            return cache[key]
        else
            local y = f(arg)
            cache[key] = y
            return y
        end
    end
end

function escape_pattern(text)
    return text:gsub("([^%w])", "%%%1")
end

MemoizeCache = {
	unnamed = {}
}

function MemoizeCache.new(id)
	id = id or "unnamed"
	if not MemoizeCache[id] then MemoizeCache[id] = {} end
	local cache_by_id = MemoizeCache[id]

	local tbl = {}
	cache_by_id[#cache_by_id+1] = tbl
	return tbl
end

function MemoizeCache._reset_id(id)
	if type(MemoizeCache[id]) ~= 'table' then return end
	for _, tbl in pairs(MemoizeCache[id]) do
		for k2 in pairs(tbl) do
			tbl[k2] = nil
		end
	end
end

function MemoizeCache.reset(id)
	if id then
		MemoizeCache._reset_id(id)
		return
	end
	for k in pairs(MemoizeCache) do
		MemoizeCache._reset_id(k)
	end
end

function defaultdict(factory)
	local tbl = {}
	local metatbl = {}
	if type(factory) == "function" then
		metatbl.__index = function (self, k)
			local v = factory()
			self[k] = v
			return v
		end
	else
		metatbl.__index = function (self, k)
			local v = factory
			self[k] = v
			return v
		end
	end
	setmetatable(tbl, metatbl)
	return tbl
end

function convert_type(str)
	if tonumber(str) then
		return tonumber(str)
	elseif str == "true" then
		return true
	elseif str == "false" then
		return false
	else
		return str
	end
end

function lookup_path(path, origin)
	local curr = origin
	for k in string.gmatch(path, "[^%.]+") do
		curr = curr[k]
	end
	return curr
end
