local trace_dbg = igi_helper.trace_dbg
local trace_assert = igi_helper.trace_assert
local TASK_STATUSES = igi_subtask.TASK_STATUSES
local set = igi_utils.Set.from_list

function has_material_rewards(CACHE)
	local _, high = get_reward_bounds(CACHE.entities, TASK_STATUSES)
	return high > 0
end

function collect_and_give_rewards(CACHE)
	local total = CACHE.complexity or collect_rewards(CACHE.entities)
	local rewards = split_to_rewards(total)

	trace_dbg("rewards", rewards)
	igi_callbacks.invoke_callbacks("on_before_rewarding", rewards)
	local faction = igi_helper.get_community_by_id(CACHE.task_giver_id)
	give_rewards(rewards, faction)
end

function collect_rewards(entities)
	local low, high = get_reward_bounds(entities, set { TASK_STATUSES.COMPLETED })
	if (low ~= high) then
		igi_helper.trace_error("Rewards did not converge, low: " .. low .. " high: " .. high)
	end
	return low
end

function guess_rewards(CACHE)
	if CACHE.complexity then
		local rw = split_to_rewards(CACHE.complexity)
		return rw, rw
	end
	local entities = CACHE.entities
	local low, high = get_reward_bounds(entities, TASK_STATUSES)
	trace_assert(low ~= nil, "Low reward bound is nil")
	if high == nil then
		high = low
	end
	return split_to_rewards(low), split_to_rewards(high)
end

function get_reward_bounds(entities, allowed_statuses)
	local lower_bound = 0
	local higher_bound = 0
	for _, entity in pairs(entities) do
		if entity.target and allowed_statuses[entity.status or ""] then
			local target_tbl = igi_taskdata.get_target_table(entity.target)
			local low, high = target_tbl.get_complexity(entity)
			if high == nil then high = low end
			lower_bound = lower_bound + low
			higher_bound = higher_bound + high
		end
	end
	return lower_bound, higher_bound
end

function split_to_rewards(points)
	local scaled_points = points * (game_difficulties.get_eco_factor("rewards") or 1)
	local money = Money.points_to_value(scaled_points * 0.8) * igi_mcm.get_options_value("money_reward_coeff")
	local goodwill = Goodwill.points_to_value(scaled_points * 0.2)
	return {
		money = math.floor(money),
		goodwill = math.ceil(goodwill),
	}
end

function give_rewards(rewards, faction)
	if (rewards.money) then
		Money.give(rewards.money)
	end

	if (rewards.goodwill) then
		Goodwill.give(rewards.goodwill, faction)
	end
end

Goodwill = {
	give = function (amount, faction)
		if amount == 0 then return end
		xr_effects.inc_faction_goodwill_to_actor(db.actor, nil, { faction, amount, true })
	end,

	points_to_value = function(points)
		return points / 50
	end
}

Money = {
	give = function (amount)
		if amount ~= 0 then
			dialogs.relocate_money(db.actor, amount, "in")
		end
	end,

	points_to_value = function (points)
		return points
	end
}

Item = {
	give = function (self)
		for section, quantity in pairs(self) do
			for _=1,quantity do
				alife_create_item(section, db.actor)
			end
			news_manager.relocate_item(db.actor, "in", section, quantity)
		end
	end,
}
