local trace_dbg = igi_helper.trace_dbg
local trace_assert = igi_helper.trace_assert
local TASK_STATUSES = igi_subtask.TASK_STATUSES

function collect_and_give_rewards(CACHE)
	local total = merge_rewards_from_subtasks(CACHE.entities, CACHE.status)
	local rewards = split_to_rewards(total)

	trace_dbg("rewards", rewards)
	igi_callbacks.invoke_callbacks("on_before_rewarding", rewards)
	local faction = igi_helper.get_community_by_id(CACHE.task_giver_id)
	give_rewards(rewards, faction)
end

function guess_rewards(entities)
	local low, high = get_reward_bounds(entities)
	trace_assert(low ~= nil, "Low reward bound is nil")
	if high == nil then
		high = low
	end
	return split_to_rewards(low), split_to_rewards(high)
end

function get_reward_bounds(entities)
	local lower_bound = 0
	local higher_bound = 0
	for _, entity in pairs(entities) do
		if entity.target then
			local target_tbl = igi_taskdata.get_target_table(entity.target)
			local low, high = target_tbl.get_complexity(entity)
			if high == nil then high = low end
			lower_bound = lower_bound + low
			higher_bound = higher_bound + high
		end
	end
	return lower_bound, higher_bound
end

function split_to_rewards(points)
	return {
		money = Money.points_to_value(points * 0.8),
		goodwill = Goodwill.points_to_value(points * 0.2),
	}
end

function merge_rewards_from_subtasks(entities, is_successful)
	local total = 0
	-- Always add failed: if task is successful then these ones are failed optionals
	total = total + merge_rewards_with_status(entities, TASK_STATUSES.FAILED)
	if is_successful then
		total = total + merge_rewards_with_status(entities, TASK_STATUSES.COMPLETED)
	end
	return total
end

function merge_rewards_with_status(entities, status)
	trace_dbg('Entities, status', entities, status)
	local total = 0
	for _, entity in pairs(entities) do
		if entity.status == status then
			local target_tbl = igi_taskdata.get_target_table(entity.target)
			total = total + target_tbl.get_complexity(entity)
		end
	end
	return total
end

function give_rewards(rewards, faction)
	if (rewards.money) then
		Money.give(rewards.money)
	end

	if (rewards.goodwill) then
		Goodwill.give(rewards.goodwill, faction)
	end
end

Goodwill = {
	give = function (amount, faction)
		if amount == 0 then return end
		xr_effects.complete_task_inc_goodwill(nil, nil, {amount, faction})
	end,

	points_to_value = function(points)
		return points / 50
	end
}

Money = {
	give = function (amount)
		money = amount*igi_mcm.get_options_value("money_reward_coeff")
		if money ~= 0 then
			local min = money*igi_mcm.get_options_value("reward_spread_min")
			local max = money*igi_mcm.get_options_value("reward_spread_max")
			xr_effects.reward_random_money(nil, nil, {min, max})
		end
	end,

	points_to_value = function (points)
		return points
	end
}

Item = {
	give = function (self)
		for section, quantity in pairs(self) do
			for _=1,quantity do
				alife_create_item(section, db.actor)
			end
			news_manager.relocate_item(db.actor, "in", section, quantity)
		end
	end,
}

function has_material_rewards(CACHE)
	for _, entity in pairs(CACHE.entities) do
		if entity.target then
			local target_tbl = igi_taskdata.get_target_table(entity.target)
			local dynamic_rewards = target_tbl.get_complexity(entity, CACHE.task_giver_id)
			if dynamic_rewards ~= 0 then
				return true
			end
		end
	end

	return false
end
