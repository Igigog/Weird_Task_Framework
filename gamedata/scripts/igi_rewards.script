local trace_assert = igi_helper.trace_assert
local trace_dbg = igi_helper.trace_dbg

local rewards_table_pattern = {
	money = 0,
	goodwill = {},
}

---------------------------< Setup >---------------------------

local function get_tg_and_tg_squad(tg)
	if tg:clsid() == clsid.online_offline_group_s then
		return igi_helper.alife_obj(tg:commander_id()), tg
	else
		return tg, get_object_squad(tg)
	end
end

local function get_tg_community_setup(se_tg, se_tg_squad)
	local community = get_object_community(se_tg)
	if string.find(community, "trader") then
		local community_setup = igi_db.get_value("misc.ltx", "trader_faction", se_tg:section_name())
		return community_setup or {se_tg_squad:get_squad_community()}
	else
		return {community}
	end
end

function get_community_setup(task_giver_id)
	local se_tg = igi_helper.alife_obj(task_giver_id)
	return get_tg_community_setup(get_tg_and_tg_squad(se_tg))
end

function setup_reward(CACHE)
	for _, entity in pairs(CACHE.target) do
		entity.reward = entity.rewards or {}
		if entity.target then
			local target_tbl = igi_taskdata.get_target_table(entity.target)
			target_tbl.setup_rewards(entity, CACHE.task_giver_id)
		end
	end
end

---------------------------< Give >--------------------------

local function populate_goodwill_table(tbl, factions, value)
	trace_assert(factions and value, "reward: no factions or value")
	-- Goodwill (1/gaussian_sum to last community, 2/sum to second last, ..., 1/2 to first)
	local parts = (#factions)*(#factions+1)/2

	for i=1,#factions do
		local faction_value = math.floor((i*value)/parts)
		local faction = factions[#factions+1-i]
		tbl[faction] = (tbl[faction] or 0) + faction_value
	end
end

local function normalize_goodwill_table(goodwill_tbl)
	local factions, value = goodwill_tbl.factions, goodwill_tbl.value
	if not value then return end

	trace_dbg("REWARD: goodwill table before", goodwill_tbl)
	empty_table(goodwill_tbl)
	populate_goodwill_table(goodwill_tbl, factions, value)
	trace_dbg("REWARD: goodwill table normalized", goodwill_tbl)
end

local function add_money_reward(dest, reward_tbl)
	if not reward_tbl.money then return end
	dest.money = dest.money + reward_tbl.money
end

local function add_goodwill_reward(dest, reward_tbl)
	if not reward_tbl.goodwill then return end
	normalize_goodwill_table(reward_tbl.goodwill)
	for faction, value in pairs(reward_tbl.goodwill) do
		if not dest.goodwill[faction] then
			dest.goodwill[faction] = 0
		end
		dest.goodwill[faction] = dest.goodwill[faction] + value
	end
end

local function add_subtask_reward(dest, subtask, status)
	local reward_tbl = subtask.reward and subtask.reward[status]
	if not reward_tbl then return end

	add_money_reward(dest, reward_tbl)
	add_goodwill_reward(dest, reward_tbl)
end

local function collect_rewards_from_subtasks(subtasks, status)
	local subtask_rewards = dup_table(rewards_table_pattern)
	for _, subtask in pairs(subtasks) do
		add_subtask_reward(subtask_rewards, subtask, status)
	end
	return subtask_rewards
end

local function collect_rewards(CACHE)
	local status = CACHE.status
	local reward_tbl = collect_rewards_from_subtasks(CACHE.target, status)
	CACHE.reward = reward_tbl
end

local function give_money_reward(CACHE)
	local money = CACHE.reward.money
	if money ~= 0 then
		xr_effects.reward_random_money(nil, nil, {money*0.8, money*1.1})
	end
end

local function give_goodwill_reward(CACHE)
	local goodwill = CACHE.reward.goodwill
	for faction, value in pairs(goodwill) do
		if value ~= 0 then
			xr_effects.complete_task_inc_goodwill(nil, nil, {value, faction})
		end
	end
end

local function give_rewards(CACHE)
	give_money_reward(CACHE)
	give_goodwill_reward(CACHE)
end

function collect_and_give_rewards(CACHE)
	collect_rewards(CACHE)
	igi_callbacks.invoke_callbacks("on_before_rewarding", CACHE)
	give_rewards(CACHE)
end
