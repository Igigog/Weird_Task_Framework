local trace_assert = igi_helper.trace_assert
local trace_dbg = igi_helper.trace_dbg

---------------------------< Setup >---------------------------

local function get_tg_and_tg_squad(tg)
	if tg:clsid() == clsid.online_offline_group_s then
		return igi_helper.alife_obj(tg:commander_id()), tg
	else
		return tg, get_object_squad(tg)
	end
end

local function get_tg_community_setup(se_tg, se_tg_squad)
	local community = get_object_community(se_tg)
	if string.find(community, "trader") then
		local community_setup = igi_db.get_value("misc.ltx", "trader_faction", se_tg:section_name())
		return community_setup or {se_tg_squad:get_squad_community()}
	else
		return {community}
	end
end

function get_community_setup(task_giver_id)
	local se_tg = igi_helper.alife_obj(task_giver_id)
	return get_tg_community_setup(get_tg_and_tg_squad(se_tg))
end

function setup_reward(CACHE)
	for _, entity in pairs(CACHE.target) do
		entity.reward = entity.rewards or {}
		if entity.target then
			local target_tbl = igi_taskdata.get_target_table(entity.target)
			target_tbl.setup_rewards(entity, CACHE.task_giver_id)
		end
	end
end

---------------------------< Give >--------------------------

local function add_goodwill_reward(rewards, goodwill_tbl)
	-- Goodwill (1/gaussian_sum to last community, 2/sum to second last, ..., 1/2 to first)
	local parts = (#rewards.factions)*(#rewards.factions+1)/2

	for i=1,#rewards.factions do
		local value = math.floor((i*rewards.goodwill)/parts)
		local faction = rewards.factions[#rewards.factions+1-i]
		goodwill_tbl[faction] = (goodwill_tbl[faction] or 0) + value
	end
end

local function add_subtask_reward(dest, subtask, status)
	local reward_tbl = subtask.reward and subtask.reward[status]

	if not reward_tbl then return end
	dest.money = (reward_tbl.money or 0) + dest.money

	if not reward_tbl.goodwill then return end
	for faction, value in pairs(reward_tbl.goodwill) do
		dest.goodwill[faction] = (dest.goodwill[faction] or 0) + value
	end
end

local function collect_rewards_from_subtasks(subtasks, status)
	local subtask_rewards = {
		money = 0,
		goodwill = {},
	}
	for _, subtask in pairs(subtasks) do
		add_subtask_reward(subtask_rewards, subtask, status)
	end
	return subtask_rewards
end

local function collect_rewards(CACHE)
	local status = CACHE.status
	local reward_tbl = collect_rewards_from_subtasks(CACHE.target, status)

	CACHE.reward = reward_tbl

	local predefined_rewards = CACHE.reward and CACHE.reward[status]
	if not predefined_rewards then return end
	if predefined_rewards.money then reward_tbl.money = predefined_rewards.money end
	if predefined_rewards.goodwill then reward_tbl.goodwill = predefined_rewards.goodwill end
end

local function give_rewards(CACHE)
	local money, goodwill = CACHE.reward.money, CACHE.reward.goodwill
	if money and money ~= 0 then
		xr_effects.reward_random_money(nil, nil, {money*0.8, money*1.1})
	end

	for faction, value in pairs(goodwill or {}) do
		if value ~= 0 then
			xr_effects.complete_task_inc_goodwill(nil, nil, {value, faction})
		end
	end
end

function collect_and_give_rewards(CACHE)
	collect_rewards(CACHE)
	igi_callbacks.invoke_callbacks("on_before_rewarding", CACHE)
	give_rewards(CACHE)
end
