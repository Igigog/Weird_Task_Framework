local trace_assert = igi_helper.trace_assert
local trace_dbg = igi_helper.trace_dbg

TASK_STATUSES = {
	RUNNING = "running",
	COMPLETED = "completed",
	FAILED = "failed",
	READY_TO_FINISH = "ready_to_finish",
	DISABLED = "disabled",
	CANCELLED = "cancelled",
}

function get_subtasks_of_status(status, CACHE)
	return CACHE.subtasks[status].payloads
end

function get_completed_subtasks(CACHE)
	return get_subtasks_of_status(TASK_STATUSES.COMPLETED, CACHE)
end

function get_running_subtasks(CACHE)
	return get_subtasks_of_status(TASK_STATUSES.RUNNING, CACHE)
end

function get_ready_to_finish_subtasks(CACHE)
	return get_subtasks_of_status(TASK_STATUSES.READY_TO_FINISH, CACHE)
end

function get_failed_subtasks(CACHE)
	return get_subtasks_of_status(TASK_STATUSES.FAILED, CACHE)
end

function iterate_subtasks(CACHE, func, ...)
	for _, subtask in pairs(CACHE.target) do
		if subtask.target then
			func(subtask, ...)
		end
	end
end

local function get_status_by_link(link, CACHE)
	local subtask = igi_linker.get_entity_from_link(link, CACHE)
	local target_tbl = igi_taskdata.get_target_table(subtask.target)
	return target_tbl.get_status(subtask)
end

local function update_subtasks_of_status(status, CACHE, new_statuses)
	local subtasks_heap = CACHE.subtasks[status]
	for i=#subtasks_heap.payloads, 1, -1 do
		local link = subtasks_heap.payloads[i]
		local new_status = get_status_by_link(link, CACHE)

		if new_status ~= status then
			new_statuses[new_status] = new_statuses[new_status] or {}
			new_statuses[new_status][#new_statuses[new_status]+1] = link
			igi_utils.heap_remove_by_index(subtasks_heap, i)
		end
	end
end

function is_task_failed(CACHE)
	for _, link in ipairs(CACHE.subtasks[TASK_STATUSES.FAILED].payloads) do
		local subtask = igi_linker.get_entity_from_link(link, CACHE)
		if not subtask.optional then return true end
	end
	return false
end

function update_subtask_status_by_link(link, new_status, CACHE)
	local subtask = igi_linker.get_entity_from_link(link, CACHE)
	igi_utils.heap_remove_element(CACHE.subtasks[subtask.status], link)
	igi_utils.heap_push(CACHE.subtasks[new_status], link, subtask.order)

	-- call all callbacks
	subtask.status = new_status
	local target_tbl = igi_taskdata.get_target_table(subtask.target)
	if target_tbl["on_"..new_status] then target_tbl["on_"..new_status](subtask, CACHE) end
	igi_callbacks.invoke_callbacks("on_subtask_status_change", CACHE, subtask, new_status)
end

function change_subtasks_status(CACHE, old_status, new_status)
	local links = get_subtasks_of_status(old_status, CACHE)
	for _, link in pairs(links) do
		update_subtask_status_by_link(link, new_status, CACHE)
	end
end

function process_subtasks(CACHE)
	local new_statuses = {}
	update_subtasks_of_status(TASK_STATUSES.RUNNING, CACHE, new_statuses)
	update_subtasks_of_status(TASK_STATUSES.READY_TO_FINISH, CACHE, new_statuses)

	for status, links in pairs(new_statuses) do
		for _, link in pairs(links) do
			update_subtask_status_by_link(link, status, CACHE)
		end
	end
end

---------------------------------------------------
function quest_target(subtasks, CACHE)
	local links = subtasks[TASK_STATUSES.RUNNING]
	if not links then return end
	for _, link in ipairs(links.payloads) do
		local subtask_data = CACHE.target[link]
		local target_tbl = igi_taskdata.get_target_table(subtask_data.target)
		local target = target_tbl.quest_target(subtask_data, CACHE)
		if target then return target end
	end
end
---------------------------------------------------

local function create_subtasks_table()
	local subtasks = {}
	for _, status in pairs(TASK_STATUSES) do
		subtasks[status] = igi_utils.heap_new()
	end
	return subtasks
end

function setup_subtask(targets)
	local subtasks = create_subtasks_table()
	for id, entity in pairs(targets) do
		if entity.target then
			igi_utils.heap_push(
				subtasks[entity.status],
				id,
				entity.order
			)
		end
	end

	return subtasks
end
---------------------------------------------------
local function update_mark(obj_data, mark_type)
	--printdbg("Igi: Spot in world: "..tostring(igi_helper.object_in_world(obj_data.se_obj)).." spot: "..tostring(level.map_has_object_spot(obj_data.id, mark_type)))
	if igi_helper.object_in_world(igi_helper.alife_obj(obj_data.id)) then
		if level.map_has_object_spot(obj_data.id, mark_type) == 0 then
			level.map_add_object_spot(obj_data.id, mark_type, game.translate_string(igi_db.TEXT_HEADER .. mark_type))
		end
	else
		if level.map_has_object_spot(obj_data.id, mark_type) == 1 then
			level.map_remove_object_spot(obj_data.id, mark_type)
		end
	end
end

function update_marks(entities)
	local marks = {
		item = "treasure_unique",
	}
	
	for entity_name, entity in pairs(entities) do
		local mark = marks[string.match(entity_name, "%$(%D+)_")]
		if mark and not entity.not_on_map then
			update_mark(entity, mark)
		end
	end
end

function unmark_all(entities)
	local marks = {
		item = "treasure_unique",
	}
	
	for entity_name, entity in pairs(entities) do
		local mark = marks[string.match(entity_name, "%$(%D+)_")]
		if mark then
			level.map_remove_object_spot(entity.id, mark)
		end
	end
end
