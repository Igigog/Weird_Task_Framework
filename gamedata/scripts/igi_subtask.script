local trace_assert = igi_helper.trace_assert
local trace_dbg = igi_helper.trace_dbg

TASK_STATUSES = {
	RUNNING = "running",
	COMPLETED = "completed",
	FAILED = "failed",
	READY_TO_FINISH = "ready_to_finish",
	DISABLED = "disabled",
}

function get_subtasks_of_status(status, CACHE)
	return CACHE.subtasks[status].payloads
end

function get_completed_subtasks(CACHE)
	return get_subtasks_of_status(TASK_STATUSES.COMPLETED, CACHE)
end

function get_running_subtasks(CACHE)
	return get_subtasks_of_status(TASK_STATUSES.RUNNING, CACHE)
end

function get_ready_to_finish_subtasks(CACHE)
	return get_subtasks_of_status(TASK_STATUSES.READY_TO_FINISH, CACHE)
end

local function get_status_by_link(link, CACHE)
	local subtask = igi_linker.get_entity_from_link(link, CACHE)
	local target_tbl = igi_taskdata.get_target_table(subtask.target)
	return target_tbl.get_status(subtask)
end

local function update_subtasks_of_status(status, CACHE, new_statuses)
	local subtasks_heap = CACHE.subtasks[status]
	for i=#subtasks_heap.payloads, 1, -1 do
		local link = subtasks_heap.payloads[i]
		local new_status = get_status_by_link(link, CACHE)

		if new_status ~= status then
			new_statuses[new_status] = new_statuses[new_status] or {}
			new_statuses[new_status][#new_statuses[new_status]+1] = link
			igi_utils.heap_remove_by_index(subtasks_heap, i)
		end
	end
end

function is_task_failed(CACHE)
	for _, link in ipairs(CACHE.subtasks[TASK_STATUSES.FAILED].payloads) do
		local subtask = igi_linker.get_entity_from_link(link, CACHE)
		if not subtask.optional then return true end
	end
	return false
end

function process_subtasks(CACHE)
	local new_statuses = {}
	local subtasks = CACHE.subtasks
	update_subtasks_of_status(TASK_STATUSES.RUNNING, CACHE, new_statuses)
	update_subtasks_of_status(TASK_STATUSES.READY_TO_FINISH, CACHE, new_statuses)

	for status, links in pairs(new_statuses) do
		for _, link in pairs(links) do
			local subtask = igi_linker.get_entity_from_link(link, CACHE)
			subtask.status = status
			igi_utils.heap_push(subtasks[status], link, subtask.order)
			igi_callbacks.invoke_callbacks("on_subtask_status_change", CACHE, subtask, status)
		end
	end
end

---------------------------------------------------
function quest_target(subtasks, CACHE)
	local links = subtasks[TASK_STATUSES.RUNNING]
	if not links then return end
	for _, link in ipairs(links.payloads) do
		local subtask_data = CACHE.target[link]
		local target_tbl = igi_taskdata.get_target_table(subtask_data.target)
		local target = target_tbl.quest_target(subtask_data, CACHE)
		if target then return target end
	end
end
---------------------------------------------------

local function create_subtasks_table()
	local subtasks = {}
	for _, status in pairs(TASK_STATUSES) do
		subtasks[status] = igi_utils.heap_new()
	end
	return subtasks
end

function setup_subtask(targets)
	local subtasks = create_subtasks_table()
	for id, entity in pairs(targets) do
		if entity.target then
			igi_utils.heap_push(
				subtasks[entity.status],
				id,
				entity.order
			)
		end
	end

	return subtasks
end
