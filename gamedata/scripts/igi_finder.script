-- Object finder functions

local WorldState = igi_world_state.WorldState
local trace_assert = igi_helper.trace_assert
local trace_dbg = igi_helper.trace_dbg

function on_game_start()
	blacklist = igi_db.SectionView("map_config.ltx", "blacklist"):as_set()
	smart_blacklist = igi_db.SectionView("map_config.ltx", "smart_blacklist"):as_set()
end

local function is_smart_good(smart_name, smart_level)
	local in_blacklist = smart_blacklist[smart_name] or
		(smart_level ~= level.name() and blacklist[smart_level])
	local is_base = simulation_objects.base_smarts[smart_name]

	local smart_id = SIMBOARD.smarts_by_names[smart_name].id
	local is_available = simulation_objects.available_by_id[smart_id]

	return is_available and not (is_base or in_blacklist)
end
------------

local function object_in_world(se_obj)
	return se_obj.parent_id == 65535
end

local function check_location(se_obj, lower_bound, higher_bound)
	local obj_level = igi_helper.get_object_level(se_obj)
	if blacklist[obj_level] then return false end

	local dist = WorldState.distance_by_level[obj_level]
	trace_dbg("Bounds", lower_bound, higher_bound, dist)
	return dist >= lower_bound and dist <= higher_bound
end

local function is_parent_enemy(se_obj)
	if se_obj.parent_id == 65535 then return end
	local my_faction = get_object_community(db.actor)
	local npc_faction = get_object_community(WorldState.objects[se_obj.parent_id])
	return game_relations.is_factions_enemies(my_faction, npc_faction)
end

function find_objects_in_world(lower_bound, higher_bound, sections)
	trace_assert(#sections > 0, "No sections were given for searching")

	local out = {}
	for _, section in pairs(sections) do
		for id in pairs(WorldState.objects_by_name[section] or {}) do
			local se_obj = WorldState.objects[id]
			if se_obj
					and check_location(se_obj, lower_bound, higher_bound)
					and object_in_world(se_obj) then
				out[#out+1] = id
			end
		end
	end

	return out
end

function find_items_in_enemy(lower_bound, higher_bound, sections)
	trace_assert(#sections > 0, "No sections were given for searching")
	
	local pool = {}
	for o_section, objects in pairs(WorldState.objects_by_name) do
		for _, section in pairs(sections) do
			if string.find(o_section, section) then
				pool[#pool+1] = objects
				break
			end
		end
	end
	
	local out = {}
	for _, group in pairs(pool) do
		for id in pairs(group) do
			local se_obj = WorldState.objects[id]
			if se_obj
					and check_location(se_obj, lower_bound, higher_bound)
					and igi_helper.is_common_npc(se_obj.parent_id)
					and is_parent_enemy(se_obj) then
				out[#out+1] = id
			end
		end
	end
	return out
end

function get_smarts(lower_bound, higher_bound)
	local smart_list = {}
	for i=lower_bound, higher_bound do
		for level in pairs(WorldState.levels_by_distance[i]) do
			for smart_name in pairs(WorldState.smarts_by_level[level]) do
				if is_smart_good(smart_name, level) then
					smart_list[#smart_list+1] = SIMBOARD.smarts_by_names[smart_name].id
				end
			end
		end
	end

	return smart_list
end

function get_smarts_string(lower_bound, higher_bound)
	return table.concat(get_smarts(lower_bound, higher_bound), ',')
end

function get_stashes(lower_bound, higher_bound)
	local stashes = treasure_manager.caches
	local returned_stashes = {}
	for id, is_not_available in pairs(stashes) do
		local se_obj = WorldState.objects[id]
		local suitable = se_obj and check_location(se_obj, lower_bound, higher_bound)
		if (not is_not_available) and suitable then
			returned_stashes[#returned_stashes+1] = id
		end
	end
	trace_dbg("Stashes: ", returned_stashes)
	return returned_stashes
end

function get_stashes_string(lower_bound, higher_bound)
	return table.concat(get_smarts(lower_bound, higher_bound), ',')
end
