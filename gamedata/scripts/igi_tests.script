local trace_assert = igi_helper.trace_assert
local trace_dbg = igi_helper.trace_dbg

function on_game_start()
    RegisterScriptCallback("save_state", save_state)
    RegisterScriptCallback("load_state", load_state)
    RegisterScriptCallback("actor_on_first_update", actor_on_first_update)
    RegisterScriptCallback("on_key_press", on_key_press)
end

STATE = {
    current_tests_name = nil,
    current_test = nil,
    last_test = nil,
    current_test_state = nil,
}

TESTS = {}
SUBTASK_TESTS = {}

function on_key_press(key)
    if not igi_mcm.get_options_value("debug") then return end
    if STATE.current_tests_name then return end
    if key == DIK_keys.DIK_K then 
        start_integration_tests("entity")
    elseif key == DIK_keys.DIK_H then
        start_integration_tests("quest")
    elseif key == DIK_keys.DIK_E then
        start_normal_tests()
    end
end

function save_state(m_data)
    m_data.igi_tests_state = STATE
end

function load_state(m_data)
    STATE = m_data.igi_tests_state or STATE
end

function actor_on_first_update()
    if not STATE.current_tests_name then return end
    if STATE.current_tests_name == "normal" then
        CreateTimeEvent("igi_tests", "tests", 2, normal_tests_worker)
        CreateTimeEvent("igi_tests", "current_test", 2, continue_test_worker)
    else
        CreateTimeEvent("igi_tests", "tests", 2, integration_tests_worker)
        CreateTimeEvent("igi_tests", "current_test", 2, continue_test_worker)
    end
end

function prepare_mock_quest(cache, id)
    local tg_id = get_story_se_object("bar_visitors_barman_stalker_trader").id
    return igi_generic_task.try_prepare_quest(id, cache, tg_id)
end

function register_subtask_test(id, cache)
    trace_assert(not SUBTASK_TESTS[id], "Subtask test already registered: "..id)
    cache.update_delay = 0
    igi_taskdata.finalize_task_cache(cache, id)
    SUBTASK_TESTS[id] = cache
end

function register_test(id, f, state)
    TESTS[id] = {id, f, state}
end

local flatenned_quests = {}
function flat_quests()
    if not next(flatenned_quests) then
        for prefix, quests in pairs(igi_taskdata.get_all_quests()) do
            for quest_name, cache in pairs(quests) do
                flatenned_quests[prefix..quest_name] = cache
            end
        end
    end
    return flatenned_quests
end

function start_integration_tests(test_type)
    xrs_debug_tools.debug_invis = true
    STATE.current_tests_name = test_type
    CreateTimeEvent("igi_tests", "tests", 2, integration_tests_worker)
end

function integration_tests_worker()
    if STATE.current_test then return end
    local caches = STATE.current_tests_name == "entity" and SUBTASK_TESTS or flat_quests()
    local id, next_cache = next(caches, STATE.last_test)
    STATE.last_test = id
    if id then
        start_integration_test(id, next_cache)
        return
    end

    STATE.current_tests_name = nil
    return true
end

function start_integration_test(id, cache)
    trace_assert(not STATE.current_test, "Already running a test!")
    trace_dbg("Running test: "..id, cache)
    STATE.current_test = id

    if prepare_mock_quest(cache, id) then
        task_manager.get_task_manager():give_task(id)
        CreateTimeEvent("igi_tests", "current_test", 0, continue_test_worker)
    else
        assert_test(nil, "Can't prepare quest")
    end
end

local function choose_entity(CACHE)
    trace_dbg("choose entity", CACHE)
    if not CACHE._test_entity_id then
        local k, entity = next(CACHE.entities, nil)
        CACHE._test_entity_id = k
    end

    local entity = CACHE.entities[CACHE._test_entity_id]
    while entity.status ~= "RUNNING" or not entity.target do
        local k
        k, entity = next(CACHE.entities, CACHE._test_entity_id)
        CACHE._test_entity_id = k
        if not k then
            trace_dbg("chosen: ", "nil")
            return nil
        end
    end
    trace_dbg("chosen: ", CACHE._test_entity_id)
    return entity
end

function continue_test_worker()
    local id = STATE.current_test
    trace_dbg("continuing test "..id, igi_generic_task.TASKS_CACHE[id])
    local CACHE = igi_generic_task.TASKS_CACHE[id]
    if not CACHE then
        finish_test()
        return true
    end
    local entity = choose_entity(CACHE)
    if not entity then
        assert_test(CACHE.status == "COMPLETED" or CACHE.status == "READY_TO_FINISH", "Quest was not completed")
        finish_test()
        return true
    end

    local target_tbl = igi_taskdata.get_target_table(entity.target)
    trace_assert(target_tbl.test, "Test is not implemented for target "..entity.target)

    local finished = target_tbl.test(entity)
    if finished then
        finish_test()
        return true
    end
    ResetTimeEvent("igi_tests", "current_test", 1)
end

function finish_test()
    if not STATE.current_test then return end
    trace_dbg("Test concluded! "..STATE.current_test)
    task_manager.get_task_manager():set_task_completed(STATE.current_test)
    STATE.current_test = nil
end

function assert_test(successful, reason)
    if successful then return successful end
    actor_menu.set_fade_msg("WTF: test "..STATE.current_test.." failed: "..reason, 10, {G = 10, B = 10})
    finish_test()
end

local function get_level_id(se_obj)
	local WorldState = igi_world_state.WorldState
    return WorldState.gg:vertex(se_obj.m_game_vertex_id):level_id()
end

function travel_to_se_obj(se_obj)
    if get_level_id(se_obj) == get_level_id(alife():object(0)) then
		db.actor:set_actor_position(se_obj.position)
	else
		ChangeLevel(se_obj.position, se_obj.m_level_vertex_id, se_obj.m_game_vertex_id, VEC_ZERO, false)
	end
end

function start_normal_tests()
    xrs_debug_tools.debug_invis = true
    STATE.current_tests_name = "normal"
    CreateTimeEvent("igi_tests", "tests", 1, normal_tests_worker)
end

function normal_tests_worker()
    if STATE.current_test then return end
    local id, data = next(TESTS, STATE.last_test)
    STATE.last_test = id
    if not id then
        STATE.current_tests_name = nil
        return true
    end

    trace_dbg("Running test: "..id, data)
    STATE.current_test = id
    STATE.current_test_state = dup_table(data[2])
    CreateTimeEvent("igi_tests", "current_test", 1, continue_normal_test_worker)
end

function continue_normal_test_worker(id)
    ResetTimeEvent("igi_tests", "current_test", 1)
    trace_dbg("continuing test "..id, STATE.current_test_state)
    return TESTS[id][1](STATE.current_test_state)
end
